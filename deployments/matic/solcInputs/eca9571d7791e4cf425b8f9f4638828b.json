{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/stableSwap/OracleVPeg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/ISwap.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"../libraries/UQ112x112.sol\";\n\n// fixed window oracle that recomputes the average price for the entire epochPeriod once every epochPeriod\n// note that the price average is only guaranteed to be over at least 1 epochPeriod, but may be over a longer epochPeriod\n// @dev This version 2 supports querying twap with shorted period (ie 2hrs for BSDB reference price)\ncontract OracleVPeg {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    /* ========= CONSTANT VARIABLES ======== */\n\n    uint256 public oneAmountTokenMain = 10**18;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // governance\n    address public operator;\n\n    // epoch\n    uint256 public lastEpochTime;\n    uint256 public epoch; // for display only\n    uint256 public epochPeriod;\n    uint256 public maxEpochPeriod = 1 days;\n\n    // 2-hours update\n    uint256 public lastUpdateHour;\n    uint256 public updatePeriod;\n\n    mapping(uint256 => uint112) public epochPrice;\n\n    // BPool\n    address public mainToken;\n    uint256 public mainTokenDecimal;\n    uint8 public mainTokenIndex;\n    uint8 public sideTokenIndex;\n    uint256 public sideTokenDecimal;\n    ISwap public pool;\n\n    // Pool price for update in cumulative epochPeriod\n    uint32 public blockTimestampCumulativeLast;\n    uint public priceCumulative;\n\n    // oracle\n    uint32 public blockTimestampLast;\n    uint256 public priceCumulativeLast;\n    FixedPoint.uq112x112 public priceAverage;\n\n    bool private _initialized = false;\n\n    event Updated(uint256 priceCumulativeLast);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    function initialize (\n        address _pool,\n        address _mainToken,\n        address _sideToken,\n        uint256 _epoch,\n        uint256 _epochPeriod,\n        uint256 _lastEpochTime,\n        uint256 _updatePeriod,\n        uint256 _lastUpdateHour\n    ) public {\n        require(_initialized == false, \"OracleVPeg: Initialize must be false.\");\n\n        mainToken = _mainToken;\n        mainTokenDecimal = ERC20(_mainToken).decimals();\n        {\n            pool = ISwap(_pool);\n\n            uint8 _mainTokenIndex = pool.getTokenIndex(_mainToken);\n            uint8 _sideTokenIndex = pool.getTokenIndex(_sideToken);\n            require(pool.getTokenBalance(_mainTokenIndex) != 0 && pool.getTokenBalance(_sideTokenIndex) != 0, \"OracleVPeg: NO_RESERVES\"); // ensure that there's liquidity in the pool\n\n            mainTokenIndex = _mainTokenIndex;\n            sideTokenIndex = _sideTokenIndex;\n            sideTokenDecimal = ERC20(_sideToken).decimals();\n        }\n\n        epoch = _epoch;\n        epochPeriod = _epochPeriod;\n        lastEpochTime = _lastEpochTime;\n        lastUpdateHour = _lastUpdateHour;\n        updatePeriod = _updatePeriod;\n\n        operator = msg.sender;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setOperator(address _operator) external onlyOperator {\n        operator = _operator;\n    }\n\n    function setEpoch(uint256 _epoch) external onlyOperator {\n        epoch = _epoch;\n    }\n\n    function setEpochPeriod(uint256 _epochPeriod) external onlyOperator {\n        require(_epochPeriod >= 1 hours && _epochPeriod <= 48 hours, '_epochPeriod out of range');\n        epochPeriod = _epochPeriod;\n    }\n\n    function setLastUpdateHour(uint256 _lastUpdateHour) external onlyOperator {\n        lastUpdateHour = _lastUpdateHour;\n    }\n\n    function setUpdatePeriod(uint256 _updatePeriod) external onlyOperator {\n        require(_updatePeriod >= 1 hours && _updatePeriod <= epochPeriod, '_updatePeriod out of range');\n        updatePeriod = _updatePeriod;\n    }\n\n    function setOneAmountTokenMain(uint256 _oneAmountTokenMain) external onlyOperator {\n        oneAmountTokenMain = _oneAmountTokenMain;\n    }\n\n    function setMaxEpochPeriod(uint256 _maxEpochPeriod) external onlyOperator {\n        require(_maxEpochPeriod <= 48 hours, '_maxEpochPeriod is not valid');\n        maxEpochPeriod = _maxEpochPeriod;\n    }\n\n    function setPool(address _pool, address _sideToken) public onlyOperator {\n        pool = ISwap(_pool);\n\n        uint8 _mainTokenIndex = pool.getTokenIndex(mainToken);\n        uint8 _sideTokenIndex = pool.getTokenIndex(_sideToken);\n\n        require(pool.getTokenBalance(_mainTokenIndex) != 0 && pool.getTokenBalance(_sideTokenIndex) != 0, \"OracleVPeg: NO_RESERVES\"); // ensure that there's liquidity in the pool\n\n        mainTokenIndex = _mainTokenIndex;\n        sideTokenIndex = _sideTokenIndex;\n        sideTokenDecimal = ERC20(_sideToken).decimals();\n    }\n\n    /* =================== Modifier =================== */\n\n    modifier checkEpoch {\n        uint256 _nextEpochPoint = nextEpochPoint();\n        require(block.timestamp >= _nextEpochPoint, \"OracleVPeg: not opened yet\");\n\n        _;\n\n        for (;;) {\n            lastEpochTime = _nextEpochPoint;\n            ++epoch;\n            _nextEpochPoint = nextEpochPoint();\n            if (block.timestamp < _nextEpochPoint) break;\n        }\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"OracleVPeg: caller is not the operator\");\n        _;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function nextEpochPoint() public view returns (uint256) {\n        return lastEpochTime.add(epochPeriod);\n    }\n\n    function nextUpdateHour() public view returns (uint256) {\n        return lastUpdateHour.add(updatePeriod);\n    }\n\n    /* ========== MUTABLE FUNCTIONS ========== */\n    // update reserves and, on the first call per block, price accumulators\n    function updateCumulative() public {\n        uint256 _updatePeriod = updatePeriod;\n        uint256 _nextUpdateHour = lastUpdateHour.add(_updatePeriod);\n        if (block.timestamp >= _nextUpdateHour) {\n            uint tokenMainPrice;\n\n            {\n                uint _decimalFactor = 10 ** (mainTokenDecimal.sub(sideTokenDecimal));\n                tokenMainPrice = pool.calculateSwap(mainTokenIndex, sideTokenIndex, oneAmountTokenMain).mul(_decimalFactor);\n                require(tokenMainPrice != 0, \"!price\");\n                require(tokenMainPrice <= uint112(-1), \"OracleVPeg: overflow\");\n            }\n\n            uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n            uint32 timeElapsed = blockTimestamp - blockTimestampCumulativeLast; // overflow is desired\n\n            if (timeElapsed > 0) {\n                // * never overflows, and + overflow is desired\n                priceCumulative += uint(UQ112x112.encode(uint112(tokenMainPrice)).uqdiv(uint112(oneAmountTokenMain))) * timeElapsed;\n\n                blockTimestampCumulativeLast = blockTimestamp;\n            }\n\n            for (;;) {\n                if (block.timestamp < _nextUpdateHour.add(_updatePeriod)) {\n                    lastUpdateHour = _nextUpdateHour;\n                    break;\n                } else {\n                    _nextUpdateHour = _nextUpdateHour.add(_updatePeriod);\n                }\n            }\n        }\n    }\n\n    /** @dev Updates 1-day EMA price.  */\n    function update() external checkEpoch {\n        updateCumulative();\n\n        uint32 timeElapsed = blockTimestampCumulativeLast - blockTimestampLast; // overflow is desired\n\n        if (timeElapsed == 0) {\n            if (epochPrice[epoch] == 0) {\n                epochPrice[epoch] = priceAverage.decode();\n            }\n\n            // prevent divided by zero\n            return;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\n\n        priceCumulativeLast = priceCumulative;\n        blockTimestampLast = blockTimestampCumulativeLast;\n\n        epochPrice[epoch] = priceAverage.decode();\n        emit Updated(priceCumulative);\n    }\n\n    // note this will always return 0 before update has been called successfully for the first time.\n    function consult(address token, uint256 amountIn) external view returns (uint144 amountOut) {\n        require(token == mainToken, \"OracleVPeg: INVALID_TOKEN\");\n        require(block.timestamp.sub(blockTimestampLast) <= maxEpochPeriod, \"OracleVPeg: Price out-of-date\");\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function twap(uint256 _amountIn) external view returns (uint144) {\n        uint32 timeElapsed = blockTimestampCumulativeLast - blockTimestampLast;\n        return (timeElapsed == 0) ? priceAverage.mul(_amountIn).decode144() : FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\n    }\n\n    function governanceRecoverUnsupported(IERC20 _token, uint256 _amount, address _to) external onlyOperator {\n        _token.transfer(_to, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface ISwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getTokenLength() external view returns (uint);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function swapStorage() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, address);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // withdraw fee update function\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory);\n\n    function calculateTokenAmount(\n        address account,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(\n        address account,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "pragma solidity ^0.7.6;\n\nimport \"./Babylonian.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n    uint256 private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z;\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "pragma solidity >=0.6.12;\n\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/stableSwap/OracleMultiVPeg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/ISwap.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"../libraries/UQ112x112.sol\";\n\n// fixed window oracle that recomputes the average price for the entire epochPeriod once every epochPeriod\n// note that the price average is only guaranteed to be over at least 1 epochPeriod, but may be over a longer epochPeriod\n// @dev This version 2 supports querying twap with shorted period (ie 2hrs for BSDB reference price)\ncontract OracleMultiVPeg {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    /* ========= CONSTANT VARIABLES ======== */\n\n    uint256 public oracleReserveMinimum;\n    uint256 public oneAmountTokenMain = 10**18;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // governance\n    address public operator;\n\n    // epoch\n    uint256 public startTime;\n    uint256 public lastEpochTime;\n    uint256 public epoch; // for display only\n    uint256 public epochPeriod;\n    uint256 public maxEpochPeriod = 1 days;\n\n    // 2-hours update\n    uint256 public lastUpdateHour;\n    uint256 public updatePeriod;\n\n    mapping(uint256 => uint112) public epochPrice;\n\n    // BPool\n    address public mainToken;\n    uint256 public mainTokenDecimal;\n    address[] public sideTokens;\n    uint8[] public mainTokenIndexs;\n    uint8[] public sideTokenIndexs;\n    uint256[] public sideTokenDecimals;\n    ISwap[] public pools;\n\n    // Pool price for update in cumulative epochPeriod\n    uint32 public blockTimestampCumulativeLast;\n    uint public priceCumulative;\n\n    // oracle\n    uint32 public blockTimestampLast;\n    uint256 public priceCumulativeLast;\n    FixedPoint.uq112x112 public priceAverage;\n\n    bool private _initialized = false;\n\n    event Updated(uint256 priceCumulativeLast);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    function initialize (\n        address[] memory _pools,\n        address _mainToken,\n        address[] memory _sideTokens,\n        uint256 _epoch,\n        uint256 _epochPeriod,\n        uint256 _lastEpochTime,\n        uint256 _updatePeriod,\n        uint256 _lastUpdateHour\n    ) public {\n        require(_initialized == false, \"OracleMultiVPeg: Initialize must be false.\");\n        require(_pools.length == _sideTokens.length, \"ERR_LENGTH_MISMATCH\");\n\n        mainToken = _mainToken;\n        mainTokenDecimal = ERC20(_mainToken).decimals();\n\n        for (uint256 i = 0; i < _pools.length; i++) {\n            ISwap pool = ISwap(_pools[i]);\n\n            uint8 mainTokenIndex = pool.getTokenIndex(_mainToken);\n            uint8 sideTokenIndex = pool.getTokenIndex(_sideTokens[i]);\n            require(pool.getTokenBalance(mainTokenIndex) != 0 && pool.getTokenBalance(sideTokenIndex) != 0, \"OracleMultiVPeg: NO_RESERVES\"); // ensure that there's liquidity in the pool\n\n            pools.push(pool);\n            sideTokens.push(_sideTokens[i]);\n            mainTokenIndexs.push(mainTokenIndex);\n            sideTokenIndexs.push(sideTokenIndex);\n            sideTokenDecimals.push(ERC20(_sideTokens[i]).decimals());\n        }\n\n        epoch = _epoch;\n        epochPeriod = _epochPeriod;\n        lastEpochTime = _lastEpochTime;\n        lastUpdateHour = _lastUpdateHour;\n        updatePeriod = _updatePeriod;\n\n        operator = msg.sender;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setOperator(address _operator) external onlyOperator {\n        operator = _operator;\n    }\n\n    function setEpoch(uint256 _epoch) external onlyOperator {\n        epoch = _epoch;\n    }\n\n    function setEpochPeriod(uint256 _epochPeriod) external onlyOperator {\n        require(_epochPeriod >= 1 hours && _epochPeriod <= 48 hours, '_epochPeriod out of range');\n        epochPeriod = _epochPeriod;\n    }\n\n    function setLastUpdateHour(uint256 _lastUpdateHour) external onlyOperator {\n        lastUpdateHour = _lastUpdateHour;\n    }\n\n    function setUpdatePeriod(uint256 _updatePeriod) external onlyOperator {\n        require(_updatePeriod >= 1 hours && _updatePeriod <= epochPeriod, '_updatePeriod out of range');\n        updatePeriod = _updatePeriod;\n    }\n\n    function setOracleReserveMinimum(uint256 _oracleReserveMinimum) external onlyOperator {\n        oracleReserveMinimum = _oracleReserveMinimum;\n    }\n\n    function setOneAmountTokenMain(uint256 _oneAmountTokenMain) external onlyOperator {\n        oneAmountTokenMain = _oneAmountTokenMain;\n    }\n\n    function setMaxEpochPeriod(uint256 _maxEpochPeriod) external onlyOperator {\n        require(_maxEpochPeriod <= 48 hours, '_maxEpochPeriod is not valid');\n        maxEpochPeriod = _maxEpochPeriod;\n    }\n\n    function addPool(address _pool, address _sideToken) public onlyOperator {\n        ISwap pool = ISwap(_pool);\n\n        uint8 mainTokenIndex = pool.getTokenIndex(mainToken);\n        uint8 sideTokenIndex = pool.getTokenIndex(_sideToken);\n\n        require(pool.getTokenBalance(mainTokenIndex) != 0 && pool.getTokenBalance(sideTokenIndex) != 0, \"OracleMultiVPeg: NO_RESERVES\"); // ensure that there's liquidity in the pool\n\n        pools.push(pool);\n        sideTokens.push(_sideToken);\n        mainTokenIndexs.push(mainTokenIndex);\n        sideTokenIndexs.push(sideTokenIndex);\n        sideTokenDecimals.push(ERC20(_sideToken).decimals());\n    }\n\n    function removePool(address _pool, address _sideToken) public onlyOperator {\n        uint last = pools.length - 1;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            if (address(pools[i]) == _pool && sideTokens[i] == _sideToken) {\n                pools[i] = pools[last];\n                sideTokens[i] = sideTokens[last];\n                mainTokenIndexs[i] = mainTokenIndexs[last];\n                sideTokenIndexs[i] = sideTokenIndexs[last];\n                sideTokenDecimals[i] = sideTokenDecimals[last];\n\n                pools.pop();\n                sideTokens.pop();\n                mainTokenIndexs.pop();\n                sideTokenIndexs.pop();\n                sideTokenDecimals.pop();\n\n                break;\n            }\n        }\n    }\n\n    /* =================== Modifier =================== */\n\n    modifier checkEpoch {\n        uint256 _nextEpochPoint = nextEpochPoint();\n        require(block.timestamp >= _nextEpochPoint, \"OracleMultiVPeg: not opened yet\");\n\n        _;\n\n        for (;;) {\n            lastEpochTime = _nextEpochPoint;\n            ++epoch;\n            _nextEpochPoint = nextEpochPoint();\n            if (block.timestamp < _nextEpochPoint) break;\n        }\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"OracleMultiVPeg: caller is not the operator\");\n        _;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function nextEpochPoint() public view returns (uint256) {\n        return lastEpochTime.add(epochPeriod);\n    }\n\n    function nextUpdateHour() public view returns (uint256) {\n        return lastUpdateHour.add(updatePeriod);\n    }\n\n    /* ========== MUTABLE FUNCTIONS ========== */\n    // update reserves and, on the first call per block, price accumulators\n    function updateCumulative() public {\n        uint256 _updatePeriod = updatePeriod;\n        uint256 _nextUpdateHour = lastUpdateHour.add(_updatePeriod);\n        if (block.timestamp >= _nextUpdateHour) {\n            uint totalMainPriceWeight;\n            uint totalMainPoolBal;\n\n            for (uint256 i = 0; i < pools.length; i++) {\n                uint _decimalFactor = 10 ** (mainTokenDecimal.sub(sideTokenDecimals[i]));\n                uint tokenMainPrice = pools[i].calculateSwap(mainTokenIndexs[i], sideTokenIndexs[i], oneAmountTokenMain).mul(_decimalFactor);\n                require(tokenMainPrice != 0, \"!price\");\n\n                uint tokenBal = pools[i].getTokenBalance(mainTokenIndexs[i]);\n                totalMainPriceWeight = totalMainPriceWeight.add(tokenMainPrice.mul(tokenBal));\n                totalMainPoolBal = totalMainPoolBal.add(tokenBal);\n            }\n\n            require(totalMainPriceWeight <= uint112(- 1) && totalMainPoolBal <= uint112(- 1), 'BPool: OVERFLOW');\n            uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n            uint32 timeElapsed = blockTimestamp - blockTimestampCumulativeLast; // overflow is desired\n\n            if (timeElapsed > 0 && totalMainPoolBal != 0) {\n                // * never overflows, and + overflow is desired\n                priceCumulative += uint(UQ112x112.encode(uint112(totalMainPriceWeight)).uqdiv(uint112(totalMainPoolBal))) * timeElapsed;\n\n                blockTimestampCumulativeLast = blockTimestamp;\n            }\n\n            for (;;) {\n                if (block.timestamp < _nextUpdateHour.add(_updatePeriod)) {\n                    lastUpdateHour = _nextUpdateHour;\n                    break;\n                } else {\n                    _nextUpdateHour = _nextUpdateHour.add(_updatePeriod);\n                }\n            }\n        }\n    }\n\n    /** @dev Updates 1-day EMA price.  */\n    function update() external checkEpoch {\n        updateCumulative();\n\n        uint32 timeElapsed = blockTimestampCumulativeLast - blockTimestampLast; // overflow is desired\n\n        if (timeElapsed == 0) {\n            if (epochPrice[epoch] == 0) {\n                epochPrice[epoch] = priceAverage.decode();\n            }\n\n            // prevent divided by zero\n            return;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\n\n        priceCumulativeLast = priceCumulative;\n        blockTimestampLast = blockTimestampCumulativeLast;\n\n        epochPrice[epoch] = priceAverage.decode();\n        emit Updated(priceCumulative);\n    }\n\n    // note this will always return 0 before update has been called successfully for the first time.\n    function consult(address token, uint256 amountIn) external view returns (uint144 amountOut) {\n        require(token == mainToken, \"OracleMultiVPeg: INVALID_TOKEN\");\n        require(block.timestamp.sub(blockTimestampLast) <= maxEpochPeriod, \"OracleMultiVPeg: Price out-of-date\");\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function twap(uint256 _amountIn) external view returns (uint144) {\n        uint32 timeElapsed = blockTimestampCumulativeLast - blockTimestampLast;\n        return (timeElapsed == 0) ? priceAverage.mul(_amountIn).decode144() : FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\n    }\n\n    function governanceRecoverUnsupported(IERC20 _token, uint256 _amount, address _to) external onlyOperator {\n        _token.transfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/StakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/IEpochController.sol\";\nimport \"./interfaces/IStakePoolEpochReward.sol\";\nimport \"./interfaces/IStakePoolController.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./interfaces/IStakePoolRewardFund.sol\";\n\n// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\ncontract StakePoolEpochReward is IStakePoolEpochReward {\n    using SafeMath for uint;\n    uint public override version;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastSnapshotIndex;\n        uint256 rewardEarned;\n        uint256 epochTimerStart;\n    }\n\n    struct Snapshot {\n        uint256 time;\n        uint256 rewardReceived;\n        uint256 rewardPerShare;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public override epochController;\n    address public override rewardToken;\n\n    uint256 public withdrawLockupEpochs;\n    uint256 public rewardLockupEpochs;\n\n    mapping(address => UserInfo) public userInfo;\n    Snapshot[] public snapshotHistory;\n\n    address public override stakeToken;\n    address public override rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint public balance;\n    uint private _unlocked = 1;\n    bool private _initialized = false;\n    uint256 public constant BLOCKS_PER_DAY = 28800;\n\n    constructor(address _controller, uint _version) public {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n        Snapshot memory genesisSnapshot = Snapshot({time : block.number, rewardReceived : 0, rewardPerShare : 0});\n        snapshotHistory.push(genesisSnapshot);\n    }\n\n    modifier lock() {\n        require(_unlocked == 1, 'StakePoolEpochReward: LOCKED');\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"StakePoolEpochReward: !timelock\");\n        _;\n    }\n\n    modifier onlyEpochController() {\n        require(msg.sender == epochController, \"StakePoolEpochReward: !epochController\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        if (_account != address(0)) {\n            UserInfo storage user = userInfo[_account];\n            user.rewardEarned = earned(_account);\n            user.lastSnapshotIndex = latestSnapshotIndex();\n        }\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _stakeToken, address _rewardFund, address _timelock, address _epochController, address _rewardToken,  uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external {\n        require(_initialized == false, \"StakePoolEpochReward: Initialize must be false.\");\n        stakeToken = _stakeToken;\n        rewardToken = _rewardToken;\n        rewardFund = _rewardFund;\n        setEpochController(_epochController);\n        setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setEpochController(address _epochController) public override lock onlyTimeLock {\n        epochController = _epochController;\n        epoch();\n        nextEpochPoint();\n        nextEpochLength();\n        nextEpochAllocatedReward();\n    }\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) public override lock onlyTimeLock {\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: out of range\"); // <= 2 week\n        withdrawLockupEpochs = _withdrawLockupEpochs;\n        rewardLockupEpochs = _rewardLockupEpochs;\n    }\n\n    function allocateReward(uint256 _amount) external override lock onlyEpochController {\n        require(_amount > 0, \"StakePoolEpochReward: Cannot allocate 0\");\n        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\n        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\n        if (balance > 0) {\n            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\n            _amount = _after.sub(_before);\n\n            // Create & add new snapshot\n            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\n            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\n\n            Snapshot memory _newSnapshot = Snapshot({\n                time: block.number,\n                rewardReceived: _amount,\n                rewardPerShare: _nextRPS\n            });\n            emit AllocateReward(block.number, _amount);\n            snapshotHistory.push(_newSnapshot);\n        }\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        if (rewardToken == _token) {\n            // do not allow to drain reward token if less than 1 week after LatestSnapshot\n            if (block.number < (getLatestSnapshot().time + (BLOCKS_PER_DAY * 7))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // =========== Epoch getters\n\n    function epoch() public override view returns (uint256) {\n        return IEpochController(epochController).epoch();\n    }\n\n    function nextEpochPoint() public override view returns (uint256) {\n        return IEpochController(epochController).nextEpochPoint();\n    }\n\n    function nextEpochLength() public override view returns (uint256) {\n        return IEpochController(epochController).nextEpochLength();\n    }\n\n    function nextEpochAllocatedReward() public override view returns (uint256) {\n        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\n    }\n\n    // =========== Snapshot getters\n\n    function latestSnapshotIndex() public view returns (uint256) {\n        return snapshotHistory.length.sub(1);\n    }\n\n    function getLatestSnapshot() internal view returns (Snapshot memory) {\n        return snapshotHistory[latestSnapshotIndex()];\n    }\n\n    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\n        return userInfo[_account].lastSnapshotIndex;\n    }\n\n    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\n        return snapshotHistory[getLastSnapshotIndexOf(_account)];\n    }\n\n    // =========== _account getters\n\n    function rewardPerShare() public view returns (uint256) {\n        return getLatestSnapshot().rewardPerShare;\n    }\n\n    function earned(address _account) public override view returns (uint256) {\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\n        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\n\n        UserInfo memory user = userInfo[_account];\n        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\n    }\n\n    function canWithdraw(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\n    }\n\n    function canClaimReward(address _account) external view returns (bool) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\n    }\n\n    function unlockWithdrawEpoch(address _account) public override view returns (uint) {\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\n    }\n\n    function unlockRewardEpoch(address _account) public override view returns (uint) {\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint _amount) external lock override {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external lock override {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"StakePoolEpochReward: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"StakePoolEpochReward: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        user.epochTimerStart = epoch(); // reset timer\n        user.amount = user.amount.add(_amount);\n        emit Deposit(_account, _amount);\n    }\n\n    function removeStakeInternal(uint _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _epoch = epoch();\n        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, \"StakePoolEpochReward: still in withdraw lockup\");\n        require(user.amount >= _amount, \"StakePoolEpochReward: invalid withdraw amount\");\n        _claimReward(false);\n        balance = balance.sub(_amount);\n        user.epochTimerStart = _epoch; // reset timer\n        user.amount = user.amount.sub(_amount);\n    }\n\n    function withdraw(uint _amount) public lock override {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 _reward = user.rewardEarned;\n        if (_reward > 0) {\n            if (_lockChecked) {\n                uint256 _epoch = epoch();\n                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, \"StakePoolEpochReward: still in reward lockup\");\n                user.epochTimerStart = _epoch; // reset timer\n            }\n            user.rewardEarned = 0;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\n            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\n            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\n        }\n    }\n\n    function claimReward() public override {\n        _claimReward(true);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external lock override {\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)),\"StakePoolEpochReward: Not allow emergencyWithdraw\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        user.rewardEarned = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IEpochController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\ninterface IEpochController {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStakePoolEpochReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IStakePoolEpochReward {\n    event AllocateReward(uint256 blocktime, uint256 amount);\n    event Deposit(address indexed account, uint256 amount);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event Withdraw(address indexed account, uint256 amount);\n\n    function version() external view returns (uint256);\n    function stakeToken() external view returns (address);\n    function rewardToken() external view returns (address);\n    function rewardFund() external view returns (address);\n    function epochController() external view returns (address);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward() external view returns (uint256);\n\n    function earned(address _account) external view returns (uint256);\n\n    function unlockWithdrawEpoch(address _account) external view returns (uint256);\n\n    function unlockRewardEpoch(address _account) external view returns (uint256);\n\n    function stake(uint256) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint256) external;\n\n    function claimReward() external;\n\n    function emergencyWithdraw() external;\n\n    function setEpochController(address) external;\n\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\n\n    function allocateReward(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IStakePoolController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity 0.7.6;\n\ninterface IStakePoolController {\n    event MasterCreated(address indexed farm, address indexed stakeToken, uint version, address timelock, address stakePoolRewardFund, uint totalStakePool);\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n    event SetStakePoolCreator(address indexed contractAddress, uint verion);\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n    event ChangeGovernance(address indexed governance);\n    event SetFeeCollector(address indexed feeCollector);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint indexed amount);\n    event SetExtraFeeRate(uint indexed amount);\n\n\n\n    function allStakePools(uint) external view returns (address stakePool);\n\n    function isStakePool(address contractAddress) external view returns (bool);\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n    function setStakePoolVerifier(address contractAddress, bool state) external;\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\n\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\n    function addStakePoolCreator(address contractAddress) external;\n\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n    function setEnableWhitelistRewardRebaser(bool value) external;\n    function setEnableWhitelistRewardMultiplier(bool value) external;\n    function allStakePoolsLength() external view returns (uint);\n\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) external returns (address);\n\n    function setGovernance(address) external;\n\n    function setFeeCollector(address _address) external;\n    function setFeeToken(address _token) external;\n    function setFeeAmount(uint _token) external;\n    function setExtraFeeRate(uint _extraFeeRate) external;\n\n}"
    },
    "contracts/interfaces/IStakePoolRewardRebaser.sol": {
      "content": "interface IStakePoolRewardRebaser {\n    function getRebaseAmount(address rewardToken, uint baseAmount) external view returns (uint);\n}"
    },
    "contracts/interfaces/IStakePoolRewardMultiplier.sol": {
      "content": "interface IStakePoolRewardMultiplier {\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerBlock) external view returns (uint);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.16;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    },
    "contracts/interfaces/IStakePoolRewardFund.sol": {
      "content": "interface IStakePoolRewardFund {\n    function initialize(address _stakePool, address _timelock) external;\n\n    function safeTransfer(address _token, address _to, uint _value) external;\n}"
    },
    "contracts/StakePoolEpochRewardCreator.sol": {
      "content": "pragma abicoder v2;\npragma solidity >=0.7.6;\n\nimport './interfaces/IStakePoolCreator.sol';\nimport './libraries/TransferHelper.sol';\nimport './TimeLock.sol';\nimport './StakePoolEpochReward.sol';\n\ncontract StakePoolEpochRewardCreator is IStakePoolCreator {\n    uint public override version = 4001;\n    struct PoolRewardInfo {\n        address epochController;\n        uint256 withdrawLockupEpochs;\n        uint256 rewardLockupEpochs;\n\n    }\n    function create() external override returns (address) {\n        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\n        return address(pool);\n    }\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external override {\n        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\n//\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data,(PoolRewardInfo));\n        pool.initialize(\n            pair,\n            address(stakePoolRewardFund),\n            address(timelock),\n            poolRewardInfo.epochController,\n            rewardToken,\n            poolRewardInfo.withdrawLockupEpochs,\n            poolRewardInfo.rewardLockupEpochs\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IStakePoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma abicoder v2;\npragma solidity 0.7.6;\n\ninterface IStakePoolCreator {\n    function version() external returns (uint);\n\n    function create() external returns (address);\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external;\n}"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract TimeLock {\n    using SafeMath for uint256;\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 1 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n    bool private _initialized;\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n    bool public admin_initialized;\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() public {\n        admin_initialized = false;\n        _initialized = false;\n    }\n\n    function initialize(address _admin, uint _delay) public {\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        admin = _admin;\n        _initialized = true;\n        emit NewAdmin(admin);\n        emit NewDelay(delay);\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint _delay) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/StakePoolCreator.sol": {
      "content": "pragma abicoder v2;\npragma solidity >=0.7.6;\n\nimport './interfaces/IStakePoolCreator.sol';\nimport './libraries/TransferHelper.sol';\nimport './TimeLock.sol';\nimport './StakePool.sol';\n\ncontract StakePoolCreator is IStakePoolCreator {\n    uint public override version = 3001;\n\n    struct PoolRewardInfo {\n        address rewardRebaser;\n        address rewardMultiplier;\n        uint256 startBlock;\n        uint256 endRewardBlock;\n        uint256 rewardPerBlock;\n        uint256 lockRewardPercent;\n        uint256 startVestingBlock;\n        uint256 endVestingBlock;\n        uint unstakingFrozenTime;\n    }\n    function create() external override returns (address) {\n        StakePool pool = new StakePool(msg.sender, version);\n        return address(pool);\n    }\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external override {\n        StakePool pool = StakePool(poolAddress);\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n        pool.addRewardPool(\n            rewardToken,\n            poolRewardInfo.rewardRebaser,\n            poolRewardInfo.rewardMultiplier,\n            poolRewardInfo.startBlock,\n            poolRewardInfo.endRewardBlock,\n            poolRewardInfo.rewardPerBlock,\n            poolRewardInfo.lockRewardPercent,\n            poolRewardInfo.startVestingBlock,\n            poolRewardInfo.endVestingBlock\n        );\n        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\n    }\n}"
    },
    "contracts/StakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/IStakePool.sol\";\nimport \"./interfaces/IStakePoolController.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./interfaces/IStakePoolRewardFund.sol\";\n\ncontract StakePool is IStakePool {\n    using SafeMath for uint;\n    uint public override version;\n    // Info of each user.\n    struct UserInfo {\n        uint amount;\n        mapping(uint8 => uint) rewardDebt;\n        mapping(uint8 => uint) reward;\n        mapping(uint8 => uint) accumulatedEarned; // will accumulate every time user harvest\n        mapping(uint8 => uint) lockReward;\n        mapping(uint8 => uint) lockRewardReleased;\n        uint lastStakeTime;\n    }\n\n    // Info of each rewardPool funding.\n    struct RewardPoolInfo {\n        address rewardToken;     // Address of rewardPool token contract.\n        address rewardRebaser;     // Address of rewardRebaser contract.\n        address rewardMultiplier;     // Address of rewardMultiplier contract.\n        uint startRewardBlock;   // Start reward block number that rewardPool distribution occurs.\n        uint lastRewardBlock;   // Last block number that rewardPool distribution occurs.\n        uint endRewardBlock;    // Block number which rewardPool distribution ends.\n        uint rewardPerBlock;    // Reward token amount to distribute per block.\n        uint accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n\n        uint lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n        uint startVestingBlock; // Block number which vesting starts.\n        uint endVestingBlock;   // Block number which vesting ends.\n        uint numOfVestingBlocks;\n\n        uint totalPaidRewards;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n    RewardPoolInfo[] public rewardPoolInfo;\n    address public override stakeToken;\n    address public rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint public balance;\n    uint public unstakingFrozenTime = 3 days;\n    uint private unlocked = 1;\n    bool private _initialized = false;\n    uint256 public constant BLOCKS_PER_DAY = 28800;\n\n    constructor(address _controller, uint _version) public {\n        controller = _controller;\n        timelock = msg.sender;\n        version = _version;\n    }\n    modifier lock() {\n        require(unlocked == 1, 'StakePool: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"StakePool: !timelock\");\n        _;\n    }\n\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\n            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n            if (rewardPool.rewardToken == _token) {\n                // do not allow to drain reward token if less than 7 days after pool ends\n                if (block.number < (rewardPool.endRewardBlock + (BLOCKS_PER_DAY * 7))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // called once by the factory at time of deployment\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external override {\n        require(_initialized == false, \"StakePool: Initialize must be false.\");\n        require(unstakingFrozenTime <= 30 days, \"StakePool: unstakingFrozenTime > 30 days\");\n        stakeToken = _stakeToken;\n        unstakingFrozenTime = _unstakingFrozenTime;\n        rewardFund = _rewardFund;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function addRewardPool(\n        address _rewardToken, address _rewardRebaser, address _rewardMultiplier,\n        uint256 _startBlock, uint256 _endRewardBlock,\n        uint256 _rewardPerBlock, uint256 _lockRewardPercent,\n        uint256 _startVestingBlock, uint256 _endVestingBlock\n    ) external override lock onlyTimeLock {\n        require(rewardPoolInfo.length <= 16, \"StakePool: Reward pool length > 16\");\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\n        require(_startVestingBlock <= _endVestingBlock, \"StakePool: startVestingBlock > endVestingBlock\");\n        _startBlock = (block.number > _startBlock) ? block.number : _startBlock;\n        require(_startBlock < _endRewardBlock, \"StakePool: startBlock >= endRewardBlock\");\n        require(_lockRewardPercent <= 100, \"StakePool: invalid lockRewardPercent\");\n        updateReward();\n        rewardPoolInfo.push(RewardPoolInfo({\n        rewardToken : _rewardToken,\n        rewardRebaser : _rewardRebaser,\n        startRewardBlock : _startBlock,\n        rewardMultiplier : _rewardMultiplier,\n        lastRewardBlock : _startBlock,\n        endRewardBlock : _endRewardBlock,\n        rewardPerBlock : _rewardPerBlock,\n        accRewardPerShare : 0,\n        lockRewardPercent : _lockRewardPercent,\n        startVestingBlock : _startVestingBlock,\n        endVestingBlock : _endVestingBlock,\n        numOfVestingBlocks : _endVestingBlock - _startVestingBlock,\n        totalPaidRewards : 0\n        }));\n        emit AddRewardPool(rewardPoolInfo.length - 1);\n    }\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardMultiplier = _rewardMultiplier;\n        updateReward(_pid);\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n    }\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardRebaser = _rewardRebaser;\n        updateReward(_pid);\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerBlock) public override view returns (uint) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardMultiplier = rewardPool.rewardMultiplier;\n        if (rewardMultiplier == address(0)) {\n            return _to.sub(_from).mul(_rewardPerBlock);\n        }\n        return IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(\n            rewardPool.startRewardBlock,\n            rewardPool.endRewardBlock,\n            _from,\n            _to,\n            _rewardPerBlock\n        );\n    }\n\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) public override view returns (uint) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        address rewardRebaser = rewardPool.rewardRebaser;\n        if (rewardRebaser == address(0)) {\n            return _pendingReward;\n        }\n        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n    }\n\n    function getRewardPerBlock(uint8 pid, uint from, uint to) public view returns (uint) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n        uint rewardPerBlock = rewardPool.rewardPerBlock;\n        if (from < rewardPool.startRewardBlock || from > rewardPool.endRewardBlock) return 0;\n        uint reward = getRewardMultiplier(pid, from, to, rewardPerBlock);\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n    }\n\n    function getRewardPerBlock(uint8 pid) external override view returns (uint) {\n        return getRewardPerBlock(pid, block.number, block.number + 1);\n    }\n\n    function updateRewardPool(uint8 _pid, uint256 _endRewardBlock, uint256 _rewardPerBlock) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        require(block.number <= rewardPool.endRewardBlock && block.number <= _endRewardBlock, \"StakePool: blockNumber > endRewardBlock\");\n        updateReward(_pid);\n        rewardPool.endRewardBlock = _endRewardBlock;\n        rewardPool.rewardPerBlock = _rewardPerBlock;\n        emit UpdateRewardPool(_pid, _endRewardBlock, _rewardPerBlock);\n    }\n\n    function stopRewardPool(uint8 _pid) public override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        updateReward(_pid);\n        rewardPool.endRewardBlock = block.number;\n        rewardPool.rewardPerBlock = 0;\n        emit UpdateRewardPool(_pid, rewardPool.endRewardBlock, rewardPool.rewardPerBlock);\n    }\n\n    function stake(uint _amount) external lock override {\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external lock override {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"StakePool: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"StakePool: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        getAllRewards(_account);\n        user.amount = user.amount.add(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n        user.lastStakeTime = block.timestamp;\n        emit Deposit(_account, _amount);\n    }\n\n    function rewardPoolInfoLength() public override view returns (uint) {\n        return rewardPoolInfo.length;\n    }\n\n    function unfrozenStakeTime(address _account) public override view returns (uint) {\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n    }\n\n    function removeStakeInternal(uint _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"StakePool: invalid withdraw amount\");\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"StakePool: frozen\");\n        getAllRewards(msg.sender);\n        balance = balance.sub(_amount);\n        user.amount = user.amount.sub(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n    }\n\n    function withdraw(uint _amount) public lock override {\n        removeStakeInternal(_amount);\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function exit() external {\n        withdraw(userInfo[msg.sender].amount);\n    }\n\n    function getAllRewards(address _account) public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            getReward(_pid, _account);\n        }\n    }\n\n    function claimReward() external override {\n        getAllRewards(msg.sender);\n    }\n\n    function getReward(uint8 _pid, address _account) public override {\n        updateReward(_pid);\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n        uint _lockRewardPercent = rewardPool.lockRewardPercent;\n        if (_lockRewardPercent > 0) {\n            if (block.number > rewardPool.endVestingBlock) {\n                uint _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n                if (_unlockReward > 0) {\n                    _pendingReward = _pendingReward.add(_unlockReward);\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n                }\n            } else {\n                if (_pendingReward > 0) {\n                    uint _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n                    _pendingReward = _pendingReward.sub(_toLocked);\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n                }\n                uint _startVestingBlock = rewardPool.startVestingBlock;\n                if (block.number > _startVestingBlock) {\n                    uint _toReleased = user.lockReward[_pid].mul(block.number.sub(_startVestingBlock)).div(rewardPool.numOfVestingBlocks);\n                    uint _lockRewardReleased = user.lockRewardReleased[_pid];\n                    if (_toReleased > _lockRewardReleased) {\n                        uint _unlockReward = _toReleased.sub(_lockRewardReleased);\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n                        _pendingReward = _pendingReward.add(_unlockReward);\n                    }\n                }\n            }\n        }\n        if (_pendingReward > 0) {\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\n            uint reward = user.reward[_pid].add(_pendingReward);\n            user.reward[_pid] = reward;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            address rewardToken = rewardPool.rewardToken;\n            uint rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n            if (rewardBalance > 0) {\n                user.reward[_pid] = 0;\n                uint rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\n                uint paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\n                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\n            }\n        }\n    }\n\n\n    function pendingReward(uint8 _pid, address _account) external override view returns (uint) {\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint lpSupply = IERC20(stakeToken).balanceOf(address(this));\n        uint _endRewardBlock = rewardPool.endRewardBlock;\n        uint _endRewardBlockApplicable = block.number > _endRewardBlock ? _endRewardBlock : block.number;\n        uint _lastRewardBlock = rewardPool.lastRewardBlock;\n        if (_endRewardBlockApplicable > _lastRewardBlock && lpSupply != 0) {\n            uint _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n        }\n        uint pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external lock override {\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"StakePool: Not allow emergencyWithdraw\");\n        UserInfo storage user = userInfo[msg.sender];\n        uint amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = 0;\n            user.reward[_pid] = 0;\n        }\n    }\n\n    function getUserInfo(uint8 _pid, address _account) public override view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased) {\n        UserInfo storage user = userInfo[_account];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt[_pid];\n        accumulatedEarned = user.accumulatedEarned[_pid];\n        lockReward = user.lockReward[_pid];\n        lockRewardReleased = user.lockRewardReleased[_pid];\n    }\n\n    function updateReward() public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            updateReward(_pid);\n        }\n    }\n\n    function updateReward(uint8 _pid) public override {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint _endRewardBlock = rewardPool.endRewardBlock;\n        uint _endRewardBlockApplicable = block.number > _endRewardBlock ? _endRewardBlock : block.number;\n        uint _lastRewardBlock = rewardPool.lastRewardBlock;\n        if (_endRewardBlockApplicable > _lastRewardBlock) {\n            uint lpSupply = IERC20(stakeToken).balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n            }\n            rewardPool.lastRewardBlock = _endRewardBlockApplicable;\n        }\n    }\n\n}\n"
    },
    "contracts/interfaces/IStakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IStakePool {\n    event Deposit(address indexed account, uint256 amount);\n    event AddRewardPool(uint256 indexed poolId);\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardBlock, uint256 rewardPerBlock);\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n    event Withdraw(address indexed account, uint256 amount);\n    function version() external view returns (uint);\n    function stakeToken() external view returns (address);\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external;\n\n    function stake(uint) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint) external;\n\n    function getReward(uint8 _pid, address _account) external;\n\n    function getAllRewards(address _account) external;\n    function claimReward() external;\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\n\n    function allowRecoverRewardToken(address _token) external view returns (bool);\n    function getRewardPerBlock(uint8 pid) external view returns (uint);\n    function rewardPoolInfoLength() external view returns (uint);\n\n    function unfrozenStakeTime(address _account) external view returns (uint);\n\n    function emergencyWithdraw() external;\n\n    function updateReward() external;\n\n    function updateReward(uint8 _pid) external;\n\n    function updateRewardPool(uint8 _pid, uint256 _endRewardBlock, uint256 _rewardPerBlock) external;\n    function stopRewardPool(uint8 _pid) external;\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerBlock) external view returns (uint);\n\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) external view returns (uint);\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n\n    function getUserInfo(uint8 _pid, address _account) external view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased);\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startBlock,\n        uint256 _endRewardBlock,\n        uint256 _rewardPerBlock,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingBlock,\n        uint256 _endVestingBlock\n    ) external;\n}\n"
    },
    "contracts/StakePoolRewardFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/IStakePoolRewardFund.sol\";\nimport \"./interfaces/IStakePool.sol\";\nimport \"./interfaces/IStakePoolRewardRebaser.sol\";\nimport \"./interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./interfaces/IStakePool.sol\";\n\ncontract StakePoolRewardFund is IStakePoolRewardFund {\n    address public stakePool;\n    address public timelock;\n    bool private _initialized;\n\n    function initialize(address _stakePool, address _timelock) external override {\n        require(_initialized == false, \"StakePoolRewardFund: already initialized\");\n        stakePool = _stakePool;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) external override {\n        require(msg.sender == stakePool, \"StakePoolRewardFund: !stakePool\");\n        TransferHelper.safeTransfer(_token, _to, _value);\n    }\n\n    function allowRecoverRewardToken(address _token) public view returns (bool){\n        return IStakePool(stakePool).allowRecoverRewardToken(_token);\n    }\n\n    function recoverRewardToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external {\n        require(msg.sender == timelock, \"StakePoolRewardFund: !timelock\");\n        require(allowRecoverRewardToken(_token), \"StakePoolRewardFund: not allow recover reward token\");\n        TransferHelper.safeTransfer(_token, _to, _amount);\n    }\n}\n"
    },
    "contracts/test/IOriginUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IOriginUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/test/OriginUniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"../libraries/SafeMath.sol\";\nimport './IOriginUniswapV2Pair.sol';\n\nlibrary OriginUniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'e4026cbe84d2014dbe102a3a287329a841eee1f461a7a55a7b168dcb1ad39eb1' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IOriginUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(9975);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\n        uint denominator = reserveOut.sub(amountOut).mul(9975);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0, 'ds-math-division-by-zero');\n        c = a / b;\n    }\n}\n"
    },
    "contracts/test/StakePoolRewardRebaserMock.sol": {
      "content": "import \"../interfaces/IStakePoolRewardRebaser.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardRebaserMock is IStakePoolRewardRebaser {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRebaseAmount(address rewardToken, uint baseAmount) external override view returns (uint) {\n        return baseAmount.mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/test/StakePoolRewardMultiplierMock.sol": {
      "content": "import \"../interfaces/IStakePoolRewardMultiplier.sol\";\nimport \"../libraries/SafeMath.sol\";\ncontract StakePoolRewardMultiplierMock is IStakePoolRewardMultiplier {\n    using SafeMath for uint;\n    uint rate;\n    constructor (uint _rate) public {\n        rate = _rate;\n    }\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerBlock) external override view returns (uint) {\n        return _to.sub(_from).mul(_rewardPerBlock) .mul(rate).div(1e18);\n    }\n}"
    },
    "contracts/test/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '../interfaces/IFireBirdPair.sol';\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1, tokenWeightA, swapFee)),\n                hex'ff8364f9bae1d17542f0940d1470ce69d18dadd4ce04eae22395ebbc5a95c314' // init code hash\n            ))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address pair, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IFireBirdPair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getOtherToken(address pair, address tokenA) internal view returns (address tokenB) {\n        address token0 = IFireBirdPair(pair).token0();\n        address token1 = IFireBirdPair(pair).token1();\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n}\n"
    },
    "contracts/interfaces/IFireBirdPair.sol": {
      "content": "pragma solidity >=0.5.16;\ninterface IFireBirdPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n    function getSwapFee() external view returns (uint32);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address, uint32, uint32) external;\n}\n"
    },
    "contracts/ProtocolFeeRemover.sol": {
      "content": "pragma solidity 0.7.6;\n\nimport './interfaces/IFireBirdPair.sol';\nimport './libraries/TransferHelper.sol';\ncontract ProtocolFeeRemover {\n    address public receiver;\n    address public governance;\n\n    event RemoveLiquidity(address indexed pair, uint token0, uint token1);\n\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n\n    function setReceiver(address _receiver) external {\n        require(msg.sender == governance, 'ProtocolFeeRemover: FORBIDDEN');\n        receiver = _receiver;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, 'ProtocolFeeRemover: FORBIDDEN');\n        governance = _governance;\n    }\n\n    function transfer(address _token, uint256 _value) external {\n        require(msg.sender == governance, 'ProtocolFeeRemover: FORBIDDEN');\n        require(receiver != address(0), 'ProtocolFeeRemover: Invalid Receiver address');\n        TransferHelper.safeTransfer(_token, receiver, _value);\n    }\n\n    function remove(address[] calldata pairs) external {\n        address _receiver = receiver;\n        // save gas\n        require(_receiver != address(0), 'ProtocolFeeRemover: Invalid Receiver address');\n        for (uint i = 0; i < pairs.length; i++) {\n            IFireBirdPair pair = IFireBirdPair(pairs[i]);\n            uint liquidity = pair.balanceOf(address(this));\n            if (liquidity > 0) {\n                pair.transfer(address(pair), liquidity);\n                (uint amount0, uint amount1) = pair.burn(_receiver);\n                emit RemoveLiquidity(address(pair), amount0, amount1);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.7.6;\n\nimport \"../interfaces/IFireBirdPair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IFireBirdPair(pair).price0CumulativeLast();\n        price1Cumulative = IFireBirdPair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IFireBirdPair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            (uint32 _tokenWeight0, uint32 _tokenWeight1) = IFireBirdPair(pair).getTokenWeights();\n            uint112 mReserve0 = reserve0 * _tokenWeight1;\n            uint112 mReserve1 = reserve1 * _tokenWeight0;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(mReserve1, mReserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(mReserve0, mReserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IFireBirdFormula.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity >=0.5.16;\n\n/*\n    Bancor Formula interface\n*/\ninterface IFireBirdFormula {\n\n    function getReserveAndWeights(address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) external view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    );\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountIn);\n\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external view returns (uint amountIn);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) external view returns (uint amountOut);\n\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external view returns (uint amountOut);\n\n    function getAmountsIn(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsIn(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsOut(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getFactoryAmountsOut(\n        address factory,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external view returns (bool);\n    function getReserves(address pair, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n    function mintLiquidityFee(\n        uint totalLiquidity,\n        uint112 reserve0,\n        uint112  reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112  collectedFee0,\n        uint112 collectedFee1) external view returns (uint amount);\n}\n"
    },
    "contracts/FireBirdRouter.sol": {
      "content": "pragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IFireBirdFactory.sol';\nimport './interfaces/IFireBirdFormula.sol';\nimport './interfaces/IFireBirdPair.sol';\nimport './libraries/TransferHelper.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IFireBirdRouter.sol';\nimport './libraries/SafeMath.sol';\nimport './interfaces/IWETH.sol';\ncontract FireBirdRouter is IFireBirdRouter {\n    using SafeMath for uint;\n    address public immutable override factory;\n    address public immutable override formula;\n    address public immutable override WETH;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        formula = IFireBirdFactory(_factory).formula();\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        (uint reserveA, uint reserveB) = IFireBirdFormula(formula).getReserves(pair, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = IFireBirdFormula(formula).quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = IFireBirdFormula(formula).quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function _addLiquidityToken(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    }\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) public virtual override returns (uint liquidity) {\n        address pair = IFireBirdFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\n        liquidity = IFireBirdPair(pair).mint(to);\n    }\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA,  amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        liquidity = IFireBirdPair(pair).mint(to);\n    }\n\n    function _addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to\n    ) internal returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            pair,\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        transferETHTo(amountETH, pair);\n        liquidity = IFireBirdPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) public virtual override payable returns (uint liquidity) {\n        address pair = IFireBirdFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\n        (,,liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\n    }\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(address tokenIn, uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        address input = tokenIn;\n        for (uint i = 0; i < path.length; i++) {\n            IFireBirdPair pairV2 = IFireBirdPair(path[i]);\n            address token0 = pairV2.token0();\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out, address output) = input == token0 ? (uint(0), amountOut, pairV2.token1()) : (amountOut, uint(0), token0);\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pairV2.swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n            emit Exchange(address(pairV2), amountOut, output);\n            input = output;\n        }\n    }\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] memory path,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amounts[0]\n        );\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amounts[0]\n        );\n        _swap(tokenIn, amounts, path, to);\n    }\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n    }\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\n\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amounts[0]\n        );\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\n\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amounts[0]\n        );\n        _swap(tokenIn, amounts, path, address(this));\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\n\n        transferETHTo(amounts[0], path[0]);\n        _swap(WETH, amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address tokenIn, address[] memory path, address _to) internal virtual {\n        address input = tokenIn;\n        for (uint i; i < path.length; i++) {\n            IFireBirdPair pair = IFireBirdPair(path[i]);\n\n            uint amountInput;\n            uint amountOutput;\n            address currentOutput;\n            {\n                (address output, uint reserveInput, uint reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IFireBirdFormula(formula).getFactoryReserveAndWeights(factory, address(pair), input);\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = IFireBirdFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n                currentOutput = output;\n            }\n            (uint amount0Out, uint amount1Out) = input == pair.token0() ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 1 ? path[i + 1] : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n            emit Exchange(address(pair), amountOutput, currentOutput);\n            input = currentOutput;\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amountIn\n        );\n        uint balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\n        require(\n            IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n//            require(path[0] == WETH, 'Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        transferETHTo(amountIn, path[0]);\n        uint balanceBefore = IERC20(tokenOut).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\n        require(\n            IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        TransferHelper.safeTransferFrom(\n            tokenIn, msg.sender, path[0], amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        transferAll(ETH_ADDRESS, to, amountOut);\n    }\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut,\n        uint deadline\n    ) public payable override virtual ensure(deadline) returns (uint totalAmountOut) {\n        transferFromAll(tokenIn, totalAmountIn);\n        uint balanceBefore;\n        if (!isETH(tokenOut)) {\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\n        }\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n            uint tokenAmountOut;\n            for (uint k = 0; k < swapSequences[i].length; k++) {\n                Swap memory swap = swapSequences[i][k];\n                if (k > 0) {\n                    // Makes sure that on the second swap the output of the first was used\n                    // so there is not intermediate token leftover\n                    swap.swapAmount = tokenAmountOut;\n                }\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\n            }\n\n            // This takes the amountOut of the last swap\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n        }\n\n        transferAll(tokenOut, msg.sender, totalAmountOut);\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n\n        if (isETH(tokenOut)) {\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n        } else {\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, '<minTotalAmountOut');\n        }\n    }\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint maxTotalAmountIn,\n        uint deadline\n    ) public payable override virtual ensure(deadline) returns (uint totalAmountIn) {\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n            uint tokenAmountInFirstSwap;\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n            if (swapSequences[i].length == 1) {\n                Swap memory swap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount, swap.maxPrice);\n\n            } else {\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n                // of token C. But first we need to buy B with A so we can then buy C with B\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\n                uint intermediateTokenAmount;\n                // This would be token B as described above\n                Swap memory secondSwap = swapSequences[i][1];\n                {\n                    address[] memory paths = new address[](1);\n                    paths[0] = secondSwap.pool;\n                    uint[] memory amounts = IFireBirdFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\n                    intermediateTokenAmount = amounts[0];\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, 'Router: EXCESSIVE_INPUT_AMOUNT');\n                }\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n                Swap memory firstSwap = swapSequences[i][0];\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount, firstSwap.maxPrice);\n\n                //// Buy the final amount of token C desired\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n        }\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\n    }\n\n    function transferFromAll(address token, uint amount) internal returns (bool) {\n        if (isETH(token)) {\n            IWETH(WETH).deposit{value : msg.value}();\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n        return true;\n    }\n\n    function getBalance(address token) internal view returns (uint) {\n        if (isETH(token)) {\n            return IWETH(WETH).balanceOf(address(this));\n        } else {\n            return IERC20(token).balanceOf(address(this));\n        }\n    }\n\n    function _swapSingleMixOut(address tokenIn, address tokenOut, address pool, uint swapAmount, uint limitReturnAmount, uint maxPrice) internal returns (uint tokenAmountIn) {\n        address[] memory paths = new address[](1);\n        paths[0] = pool;\n        uint[] memory amounts = IFireBirdFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\n        tokenAmountIn = amounts[0];\n        require(tokenAmountIn <= limitReturnAmount, 'Router: EXCESSIVE_INPUT_AMOUNT');\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\n    }\n\n    function _swapSingle(address tokenIn, address pair, uint targetSwapAmount, uint targetOutAmount) internal {\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\n        IFireBirdPair pairV2 = IFireBirdPair(pair);\n        address token0 = pairV2.token0();\n\n        (uint amount0Out, uint amount1Out, address output) = tokenIn == token0 ? (uint(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint(0), token0);\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\n        emit Exchange(pair, targetOutAmount, output);\n    }\n\n    function _swapSingleSupportFeeOnTransferTokens(address tokenIn, address tokenOut, address pool, uint swapAmount, uint limitReturnAmount) internal returns(uint tokenAmountOut) {\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\n\n        uint amountOutput;\n        {\n            (, uint reserveInput, uint reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IFireBirdFormula(formula).getFactoryReserveAndWeights(factory, pool, tokenIn);\n            uint amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\n            amountOutput = IFireBirdFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\n        }\n        uint balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        (uint amount0Out, uint amount1Out) = tokenIn == IFireBirdPair(pool).token0() ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        IFireBirdPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        emit Exchange(pool, amountOutput, tokenOut);\n\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\n        require(tokenAmountOut >= limitReturnAmount,'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n    }\n\n    function _validateAmountOut(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] memory path\n    ) internal view returns (uint[] memory amounts) {\n        amounts = IFireBirdFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n    }\n\n    function _validateAmountIn(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path\n    ) internal view returns (uint[] memory amounts) {\n        amounts = IFireBirdFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\n    }\n\n    function transferETHTo(uint amount, address to) internal {\n        IWETH(WETH).deposit{value: amount}();\n        assert(IWETH(WETH).transfer(to, amount));\n    }\n\n    function transferAll(address token, address to, uint amount) internal returns (bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            IWETH(WETH).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n        return true;\n    }\n\n    function isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n// **** REMOVE LIQUIDITY ****\n    function _removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to\n    ) internal  returns (uint amountA, uint amountB) {\n        require(IFireBirdFactory(factory).isPair(pair), \"Router: Invalid pair\");\n        IFireBirdPair(pair).transferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint amount0, uint amount1) = IFireBirdPair(pair).burn(to);\n        (address token0,) = IFireBirdFormula(formula).sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = _removeLiquidity(\n            pair,\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this)\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        {\n            uint value = approveMax ? uint(- 1) : liquidity;\n            IFireBirdPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        uint value = approveMax ? uint(- 1) : liquidity;\n        IFireBirdPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            pair,\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        transferAll(ETH_ADDRESS, to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        uint value = approveMax ? uint(- 1) : liquidity;\n        IFireBirdPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IFireBirdFactory.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IFireBirdFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint);\n    function feeTo() external view returns (address);\n    function formula() external view returns (address);\n    function protocolFee() external view returns (uint);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function isPair(address) external view returns (bool);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external returns (address pair);\n    function getWeightsAndSwapFee(address pair) external view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setProtocolFee(uint) external;\n}\n"
    },
    "contracts/interfaces/IFireBirdRouter.sol": {
      "content": "pragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IFireBirdRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint swapAmount; // tokenInAmount / tokenOutAmount\n        uint limitReturnAmount; // minAmountOut / maxAmountIn\n        uint maxPrice;\n    }\n    function factory() external view returns (address);\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut,\n        uint deadline\n    )\n    external payable returns (uint totalAmountOut);\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint maxTotalAmountIn,\n        uint deadline\n    ) external payable returns (uint totalAmountIn);\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "pragma solidity =0.7.6;\n\nimport '../interfaces/IFireBirdRouter.sol';\n\ncontract RouterEventEmitter {\n    event Amounts(uint[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapExactTokensForTokens.selector, tokenIn, tokenOut, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapTokensForExactTokens.selector, tokenIn, tokenOut, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapExactETHForTokens.selector, tokenOut, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        address tokenIn,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapTokensForExactETH.selector, tokenIn, amountOut, amountInMax, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapExactTokensForETH.selector, tokenIn, amountIn, amountOutMin, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        address tokenOut,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n                IFireBirdRouter(router).swapETHForExactTokens.selector, tokenOut, amountOut, path, to, deadline\n            ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n}\n"
    },
    "contracts/test/SimpleEpochController.sol": {
      "content": "pragma solidity 0.7.6;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IStakePoolEpochReward.sol\";\nimport '../libraries/TransferHelper.sol';\ncontract SimpleEpochController is IEpochController {\n    uint256 public _epoch = 0;\n    uint256 public epochLength = 5 minutes;\n    uint256 public lastEpochTime;\n    address public allocator;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        allocator = msg.sender;\n    }\n\n    function epoch() external override view returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external override view returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, 'SimpleEpochController: FORBIDDEN');\n        owner = _owner;\n    }\n\n    function setAllocator(address _allocator) external {\n        require(msg.sender == owner, 'SimpleEpochController: FORBIDDEN');\n        allocator = _allocator;\n    }\n    function nextEpochLength() public override view returns (uint256) {\n        return epochLength;\n    }\n\n    function allocateReward(address pool) external {\n        require(msg.sender == allocator, 'SimpleEpochController: FORBIDDEN');\n        uint256 _amount = nextEpochAllocatedReward(pool);\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        TransferHelper.safeApprove(rewardToken, pool, _amount);\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IStakePoolEpochReward(pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address pool) public override view returns (uint256) {\n        address rewardToken = IStakePoolEpochReward(pool).rewardToken();\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/test/EpochControllerMock.sol": {
      "content": "pragma solidity 0.7.6;\n\nimport \"../interfaces/IEpochController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IStakePoolEpochReward.sol\";\n\ncontract EpochControllerMock is IEpochController {\n    uint256 private _epoch = 0;\n    address public rewardToken;\n    uint256 public lastEpochTime;\n\n    constructor(address _rewardToken) {\n        rewardToken = _rewardToken;\n    }\n\n    function epoch() external override view returns (uint256) {\n        return _epoch;\n    }\n\n    function nextEpochPoint() external override view returns (uint256) {\n        return lastEpochTime + nextEpochLength();\n    }\n\n    function nextEpochLength() public override view returns (uint256) {\n        return 12 hours;\n    }\n\n    function resetEpochTime() external {\n        lastEpochTime = block.timestamp;\n    }\n\n    function updateEpochTime(uint256 _lastEpochTime) external {\n        lastEpochTime = _lastEpochTime;\n    }\n\n    function allocateSeigniorage(uint256 _amount, address _pool) external {\n        _epoch = _epoch + 1;\n        lastEpochTime = block.timestamp;\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(rewardToken).approve(_pool, 0);\n        IERC20(rewardToken).approve(_pool, _amount);\n        IStakePoolEpochReward(_pool).allocateReward(_amount);\n    }\n\n    function nextEpochAllocatedReward(address _pool) external override view returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/StakePoolController.sol": {
      "content": "pragma abicoder v2;\npragma solidity >=0.7.6;\n\nimport './interfaces/IStakePoolCreator.sol';\nimport './interfaces/IStakePoolController.sol';\nimport './interfaces/IIsPair.sol';\nimport './interfaces/IStakePool.sol';\nimport './libraries/TransferHelper.sol';\nimport './TimeLock.sol';\nimport \"./interfaces/IERC20.sol\";\nimport './StakePoolRewardFund.sol';\n\ncontract StakePoolController is IStakePoolController {\n    IIsPair public swapFactory;\n    address public governance;\n\n    address public feeCollector;\n    address public feeToken;\n    uint public  feeAmount;\n\n    mapping(address => bool) private _stakePools;\n    mapping(address => bool) private _whitelistStakingFor;\n    mapping(address => bool) private _whitelistRewardRebaser;\n    mapping(address => bool) private _whitelistRewardMultiplier;\n    mapping(address => int8) private _whitelistStakePools;\n    mapping(address => bool) public _stakePoolVerifiers;\n    mapping(uint => address) public stakePoolCreators;\n    address[] public override allStakePools;\n    bool public enableWhitelistRewardRebaser = false;\n    bool public enableWhitelistRewardMultiplier = false;\n    bool private _initialized = false;\n\n    mapping(address => bool) public allowEmergencyWithdrawStakePools;\n\n    uint public extraFeeRate;\n\n    function initialize(address _swapFactory) public {\n        require(_initialized == false, \"StakePoolController: initialized\");\n        governance = msg.sender;\n        swapFactory = IIsPair(_swapFactory);\n        _initialized = true;\n    }\n\n    function isStakePool(address b) external override view returns (bool){\n        return _stakePools[b];\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"StakePoolController: !governance\");\n        _;\n    }\n\n    function setFeeCollector(address _address) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        feeCollector = _address;\n        emit SetFeeCollector(_address);\n    }\n    function setEnableWhitelistRewardRebaser(bool value) external onlyGovernance override {\n        enableWhitelistRewardRebaser = value;\n    }\n    function setEnableWhitelistRewardMultiplier(bool value) external onlyGovernance override {\n        enableWhitelistRewardMultiplier = value;\n    }\n    function setFeeToken(address _token) external onlyGovernance override {\n        require(_token != address(0), \"StakePoolController: invalid _token\");\n        feeToken = _token;\n        emit SetFeeToken(_token);\n    }\n    function getCreationFee(address token) public view returns (uint) {\n        if (swapFactory.isPair(token)) {\n            return feeAmount;\n        }\n        return feeAmount * extraFeeRate / 1000;\n    }\n    function setFeeAmount(uint _feeAmount) external onlyGovernance override {\n        feeAmount = _feeAmount;\n        emit SetFeeAmount(_feeAmount);\n    }\n    function setExtraFeeRate(uint _extraFeeRate) external onlyGovernance override {\n        require(_extraFeeRate >= 1000 && _extraFeeRate <= 50000, \"StakePoolController: invalid _extraFeeRate\");\n        extraFeeRate = _extraFeeRate;\n        emit SetExtraFeeRate(_extraFeeRate);\n    }\n    function isWhitelistStakingFor(address _address) external override view returns (bool){\n        return _whitelistStakingFor[_address];\n    }\n\n    function isWhitelistStakePool(address _address) external override view returns (int8){\n        return _whitelistStakePools[_address];\n    }\n    function isStakePoolVerifier(address _address) external override view returns (bool){\n        return _stakePoolVerifiers[_address];\n    }\n    function isAllowEmergencyWithdrawStakePool(address _address) external override view returns (bool){\n        return allowEmergencyWithdrawStakePools[_address];\n    }\n    function setWhitelistStakingFor(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        _whitelistStakingFor[_address] = state;\n        emit SetWhitelistStakingFor(_address, state);\n    }\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        allowEmergencyWithdrawStakePools[_address] = state;\n    }\n\n    function setStakePoolVerifier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        _stakePoolVerifiers[_address] = state;\n        emit SetStakePoolVerifier(_address, state);\n    }\n\n    function setWhitelistStakePool(address _address, int8 state) external override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        require(_stakePoolVerifiers[msg.sender] == true, \"StakePoolController: invalid stake pool verifier\");\n        _whitelistStakePools[_address] = state;\n        emit SetWhitelistStakePool(_address, state);\n    }\n\n    function addStakePoolCreator(address _address) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        uint version = IStakePoolCreator(_address).version();\n        require(version >= 1000, \"Invalid stake pool creator version\");\n        stakePoolCreators[version] = _address;\n        emit SetStakePoolCreator(_address, version);\n    }\n\n    function isWhitelistRewardRebaser(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardRebaser) return true;\n        return _address == address(0) ? true : _whitelistRewardRebaser[_address];\n    }\n\n    function setWhitelistRewardRebaser(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        _whitelistRewardRebaser[_address] = state;\n        emit SetWhitelistRewardRebaser(_address, state);\n    }\n\n    function isWhitelistRewardMultiplier(address _address) external override view returns (bool){\n        if (!enableWhitelistRewardMultiplier) return true;\n        return _address == address(0) ? true : _whitelistRewardMultiplier[_address];\n    }\n\n    function setWhitelistRewardMultiplier(address _address, bool state) external onlyGovernance override {\n        require(_address != address(0), \"StakePoolController: invalid address\");\n        _whitelistRewardMultiplier[_address] = state;\n        emit SetWhitelistRewardMultiplier(_address, state);\n    }\n\n    function setGovernance(address _governance) external onlyGovernance override {\n        require(_governance != address(0), \"StakePoolController: invalid governance\");\n        governance = _governance;\n        emit ChangeGovernance(_governance);\n    }\n\n    function allStakePoolsLength() external override view returns (uint) {\n        return allStakePools.length;\n    }\n    function createInternal(address stakePoolCreator, address stakeToken, address stakePoolRewardFund, address rewardToken, uint delayTimeLock, bytes calldata data) internal returns (address) {\n        TimeLock timelock = new TimeLock();\n        IStakePool pool = IStakePool(IStakePoolCreator(stakePoolCreator).create());\n        allStakePools.push(address(pool));\n        _stakePools[address(pool)] = true;\n        emit MasterCreated(address(pool), stakeToken, pool.version(), address(timelock), stakePoolRewardFund, allStakePools.length);\n        IStakePoolCreator(stakePoolCreator).initialize(address(pool), stakeToken, rewardToken, address(timelock), address(stakePoolRewardFund), data);\n        StakePoolRewardFund(stakePoolRewardFund).initialize(address(pool), address(timelock));\n        timelock.initialize(msg.sender, delayTimeLock);\n        return address(pool);\n    }\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) public override returns (address) {\n        address stakePoolCreator = stakePoolCreators[version];\n        require(stakePoolCreator != address(0), \"StakePoolController: Invalid stake pool creator version\");\n        uint creationFee = getCreationFee(stakeToken);\n        if (feeCollector != address(0) && feeToken != address(0) && creationFee > 0) {\n            TransferHelper.safeTransferFrom(feeToken, msg.sender, feeCollector, creationFee);\n        }\n\n        StakePoolRewardFund stakePoolRewardFund = new StakePoolRewardFund();\n        if (rewardFundAmount > 0) {\n            require(IERC20(rewardToken).balanceOf(msg.sender) >= rewardFundAmount , \"StakePoolController: Not enough rewardFundAmount\");\n            TransferHelper.safeTransferFrom(rewardToken, msg.sender, address(stakePoolRewardFund), rewardFundAmount);\n        }\n        return createInternal(stakePoolCreator, stakeToken, address(stakePoolRewardFund), rewardToken, delayTimeLock, data);\n    }\n}\n"
    },
    "contracts/interfaces/IIsPair.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IIsPair {\n    function isPair(address) external view returns (bool);\n}\n"
    },
    "contracts/test/FireBirdFactoryMock.sol": {
      "content": "pragma solidity 0.7.6;\n\n\nimport \"../interfaces/IIsPair.sol\";\n\ncontract FireBirdFactoryMock is IIsPair {\n    mapping(address => bool) public override isPair;\n\n    function setIsPair(address pair, bool val) external {\n        isPair[pair] = val;\n    }\n\n}\n"
    },
    "contracts/FireBirdFormula.sol": {
      "content": "pragma solidity >=0.7.6;\n\nimport \"./interfaces/IFireBirdFormula.sol\";\nimport \"./interfaces/IFireBirdPair.sol\";\nimport \"./interfaces/IFireBirdFactory.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract FireBirdFormula is IFireBirdFormula {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE = 1;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256 private constant LAMBERT_CONV_RADIUS = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;\n    uint256 private constant LAMBERT_POS2_SAMPLE = 0x0003060c183060c183060c183060c18306;\n    uint256 private constant LAMBERT_POS2_MAXVAL = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;\n    uint256 private constant LAMBERT_POS3_MAXVAL = 0x6b22d43e72c326539cceeef8bb48f255ff;\n\n    uint256 private constant MAX_UNF_WEIGHT = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\n\n    uint256[128] private maxExpArray;\n\n    function initMaxExpArray() internal {\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n    constructor () public {\n        initMaxExpArray();\n    }\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN >= _baseD, \"not support _baseN < _baseD\");\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count;\n            // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1;\n                // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1;\n                    // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\n        // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\n        // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\n        // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\n        // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000;\n        // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\n        // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\n        // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000;\n        // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\n        // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\n        // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\n        // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000;\n        // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000;\n        // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000;\n        // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000;\n        // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000;\n        // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000;\n        // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000;\n        // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000;\n        // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000;\n        // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000;\n        // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000;\n        // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00;\n        // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00;\n        // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900;\n        // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00;\n        // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340;\n        // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40;\n        // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0;\n        // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420;\n        // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021;\n        // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001;\n        // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        }\n        // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        }\n        // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        }\n        // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        }\n        // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        }\n        // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        }\n        // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        }\n        // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        }\n        // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^01 / 01 - y^02 / 02\n        res += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^03 / 03 - y^04 / 04\n        res += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^05 / 05 - y^06 / 06\n        res += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^07 / 07 - y^08 / 08\n        res += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^09 / 09 - y^10 / 10\n        res += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^11 / 11 - y^12 / 12\n        res += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1;\n        // add y^13 / 13 - y^14 / 14\n        res += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000;\n        // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000;\n        // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000;\n        // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000;\n        // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000;\n        // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000;\n        // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000;\n        // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800;\n        // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800;\n        // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00;\n        // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400;\n        // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300;\n        // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00;\n        // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480;\n        // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380;\n        // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638;\n        // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8;\n        // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c;\n        // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014;\n        // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001;\n        // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea;\n        // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n        // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function getReserveAndWeights(address pair, address tokenA) public override view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    ) {\n        address token0 = IFireBirdPair(pair).token0();\n        (uint reserve0, uint reserve1,) = IFireBirdPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getWeightsAndSwapFee(pair);\n\n        if (tokenA == token0) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IFireBirdPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (token0, reserve1, reserve0, tokenWeight1, tokenWeight0);\n        }\n    }\n\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) public override view returns (\n        address tokenB,\n        uint reserveA,\n        uint reserveB,\n        uint32 tokenWeightA,\n        uint32 tokenWeightB,\n        uint32 swapFee\n    ) {\n        address token0 = IFireBirdPair(pair).token0();\n        (uint reserve0, uint reserve1,) = IFireBirdPair(pair).getReserves();\n        uint32 tokenWeight0;\n        uint32 tokenWeight1;\n        (tokenWeight0, tokenWeight1, swapFee) = getFactoryWeightsAndSwapFee(factory, pair);\n\n        if (tokenA == token0) {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (IFireBirdPair(pair).token1(), reserve0, reserve1, tokenWeight0, tokenWeight1);\n        } else {\n            (tokenB, reserveA, reserveB, tokenWeightA, tokenWeightB) = (token0, reserve1, reserve0, tokenWeight1, tokenWeight0);\n        }\n    }\n    /**\n         * @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset,\n         *\n         * Formula:\n         * return = reserveOut * (1 - (reserveIn / (reserveIn + amountIn * (10000 - swapFee))) ^ (tokenWeightIn / tokenWeightOut))\n         *\n         * @param amountIn                  source reserve amount\n         * @param reserveIn    source reserve balance\n         * @param reserveOut    target reserve balance\n         * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n         * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n         * @param swapFee                  swap fee of the conversion\n         *\n         * @return amountOut\n         */\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public override view returns (uint amountOut) {\n        // validate input\n        require(amountIn > 0, 'FireBirdFormula: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, \"FireBirdFormula: INSUFFICIENT_LIQUIDITY\");\n        uint amountInWithFee = amountIn.mul(10000 - swapFee);\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            return reserveOut.mul(amountInWithFee) / (reserveIn.mul(10000).add(amountInWithFee));\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = reserveIn.mul(10000).add(amountInWithFee);\n        (result, precision) = power(baseN, reserveIn.mul(10000), tokenWeightIn, tokenWeightOut);\n\n        uint256 temp1 = reserveOut.mul(result);\n        uint256 temp2 = reserveOut << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n         * @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n         *\n         * Formula:\n         * return = reserveIn * ( (reserveOut / (reserveOut - amountOut)) ^ (tokenWeightOut / tokenWeightIn) - 1) * (10000/ (10000 - swapFee)\n         *\n         * @param amountOut     target reserve amount\n         * @param reserveIn    source reserve balance\n         * @param reserveOut    target reserve balance\n         * @param tokenWeightIn     source reserve weight, represented in ppm (2-98)\n         * @param tokenWeightOut     target reserve weight, represented in ppm (2-98)\n         * @param swapFee                  swap fee of the conversion\n         *\n         * @return amountIn\n         */\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn, uint reserveOut,\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\n        uint32 swapFee\n    ) public override view returns (uint amountIn) {\n        // validate input\n        require(amountOut > 0, 'FireBirdFormula: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, \"FireBirdFormula: INSUFFICIENT_LIQUIDITY\");\n        // special case for equal weights\n        if (tokenWeightIn == tokenWeightOut) {\n            uint numerator = reserveIn.mul(amountOut).mul(10000);\n            uint denominator = reserveOut.sub(amountOut).mul(10000 - swapFee);\n            return (numerator / denominator).add(1);\n        }\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = reserveOut.sub(amountOut);\n        (result, precision) = power(reserveOut, baseD, tokenWeightOut, tokenWeightIn);\n        uint256 baseReserveIn = reserveIn.mul(10000);\n        uint256 temp1 = baseReserveIn.mul(result);\n        uint256 temp2 = baseReserveIn << precision;\n        return (((temp1 - temp2) >> precision) / (10000 - swapFee)).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address tokenIn, address tokenOut, uint amountIn, address[] calldata path) external override view returns (uint[] memory amounts) {\n        require(path.length > 0, 'FireBirdFormula: INVALID_PATH');\n        amounts = new uint[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, 'FireBirdFormula: INVALID_TOKEN_OUT_PATH');\n    }\n\n    function getFactoryAmountsOut(address factory, address tokenIn, address tokenOut, uint amountIn, address[] calldata path) external override view returns (uint[] memory amounts) {\n        require(path.length > 0, 'FireBirdFormula: INVALID_PATH');\n        amounts = new uint[](path.length + 1);\n        amounts[0] = amountIn;\n        address currentTokenIn = tokenIn;\n        for (uint i = 0; i < path.length; i++) {\n            (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(factory, path[i], currentTokenIn);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n            currentTokenIn = currentTokenOut;\n        }\n        require(currentTokenIn == tokenOut, 'FireBirdFormula: INVALID_TOKEN_OUT_PATH');\n    }\n\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external override view returns (uint amountOut) {\n        (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountOut = getAmountOut(amountIn, reserveIn, reserveOut, tokenWeightIn, tokenWeightOut, swapFee);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address tokenIn, address tokenOut, uint amountOut, address[] calldata path) external override view returns (uint[] memory amounts) {\n        require(path.length > 0, 'FireBirdFormula: INVALID_PATH');\n        amounts = new uint[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n\n        }\n        require(currentTokenIn == tokenIn, 'FireBirdFormula: INVALID_TOKEN_IN_PATH');\n    }\n\n    function getFactoryAmountsIn(address factory, address tokenIn, address tokenOut, uint amountOut, address[] calldata path) external override view returns (uint[] memory amounts) {\n        require(path.length > 0, 'FireBirdFormula: INVALID_PATH');\n        amounts = new uint[](path.length + 1);\n        amounts[amounts.length - 1] = amountOut;\n        address currentTokenIn = tokenOut;\n        for (uint i = path.length; i > 0; i--) {\n            (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getFactoryReserveAndWeights(factory, path[i - 1], currentTokenIn);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n            currentTokenIn = currentTokenOut;\n\n        }\n        require(currentTokenIn == tokenIn, 'FireBirdFormula: INVALID_TOKEN_IN_PATH');\n    }\n\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external override view returns (uint amountIn) {\n        (address currentTokenOut, uint reserveIn, uint reserveOut, uint32 tokenWeightIn, uint32 tokenWeightOut, uint32 swapFee) = getReserveAndWeights(pair, tokenIn);\n        amountIn = getAmountIn(amountOut, reserveOut, reserveIn, tokenWeightOut, tokenWeightIn, swapFee);\n    }\n\n    function getWeightsAndSwapFee(address pair) public view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee) {\n        try IFireBirdPair(pair).getTokenWeights() returns (uint32 _tokenWeight0, uint32 _tokenWeight1) {\n            return (_tokenWeight0, _tokenWeight1, IFireBirdPair(pair).getSwapFee());\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*lowLevelData*/) {\n            return (50, 50, 30);\n        }\n    }\n\n    function getFactoryWeightsAndSwapFee(address factory, address pair) public view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee) {\n        return IFireBirdFactory(factory).getWeightsAndSwapFee(pair);\n    }\n\n    // Ensure constant value reserve0^(tokenWeight0/50) * reserve1^((100 - tokenWeight0)/50) <= balance0Adjusted^(tokenWeight0/50) * balance1Adjusted^((100 - tokenWeight0)/50)\n    //  1 <= (balance0Adjusted / reserve0 )^(tokenWeight0/50) * (balance1Adjusted/reserve1)^((100 - tokenWeight0)/50)\n    //  (reserve0 / balance0Adjusted) ^ (tokenWeight0/50) <=  (balance1Adjusted / reserve1) ^ ((100 - tokenWeight0)/50)\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external override view returns (bool) {\n        if (tokenWeight0 == 50) {\n            return balance0Adjusted.mul(balance1Adjusted) >= reserve0.mul(reserve1);\n        }\n        if (balance0Adjusted >= reserve0 && balance1Adjusted >= reserve1) {\n            return true;\n        }\n        if (balance0Adjusted <= reserve0 && balance1Adjusted <= reserve1) {\n            return false;\n        }\n        uint32 w0 = tokenWeight0;\n        uint32 w1 = 100 - w0;\n\n        uint r0;\n        uint p0;\n        uint r1;\n        uint p1;\n        if (balance0Adjusted >= reserve0) {\n            (r0, p0) = power(reserve1, balance1Adjusted, w1, 50);\n            (r1, p1) = power(balance0Adjusted, reserve0, w0, 50);\n        } else {\n            (r0, p0) = power(reserve0, balance0Adjusted, w0, 50);\n            (r1, p1) = power(balance1Adjusted, reserve1, w1, 50);\n        }\n        uint minP = p0 < p1 ? p0 : p1;\n        p0 = p0 - minP;\n        p1 = p1 - minP;\n        return (r0 >> p0) <= (r1 >> p1);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\n        require(tokenA != tokenB, 'FireBirdFormula: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'FireBirdFormula: ZERO_ADDRESS');\n    }\n\n    function getReserves(address pair, address tokenA, address tokenB) external view override returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IFireBirdPair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function getOtherToken(address pair, address tokenA) external view override returns (address tokenB) {\n        address token0 = IFireBirdPair(pair).token0();\n        address token1 = IFireBirdPair(pair).token1();\n        tokenB = token0 == tokenA ? token1 : token0;\n    }\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure override returns (uint amountB) {\n        require(amountA > 0, 'FireBirdFormula: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'FireBirdFormula: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n    function mintLiquidityFee(\n        uint totalLiquidity,\n        uint112 reserve0,\n        uint112  reserve1,\n        uint32 tokenWeight0,\n        uint32 tokenWeight1,\n        uint112  collectedFee0,\n        uint112 collectedFee1) external view override returns (uint amount) {\n        if (collectedFee0 > 0) {\n            (uint r0, uint p0) = power(uint(collectedFee0).add(reserve0), reserve0, tokenWeight0, 100);\n            amount = amount.add(totalLiquidity.mul(r0) >> p0).sub(totalLiquidity);\n        }\n        if (collectedFee1 > 0) {\n            (uint r1, uint p1) = power(uint(collectedFee1).add(reserve1), reserve1, tokenWeight1, 100);\n            amount = amount.add(totalLiquidity.mul(r1) >> p1).sub(totalLiquidity);\n        }\n    }\n\n\n}\n"
    },
    "contracts/interfaces/IFireBirdRouterLite.sol": {
      "content": "pragma solidity >=0.6.12;\n\ninterface IFireBirdRouter {\n    event Exchange(\n        address pair,\n        uint amountOut,\n        address output\n    );\n    function factory() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStableSwapFactory.sol": {
      "content": "pragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStableSwapFactory {\n    event SwapCreated(IERC20[] pooledTokens, address indexed swap, uint length);\n    event SetFeeTo(address indexed feeTo);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint indexed amount);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function allPools(uint) external view returns (address pool);\n    function isPool(address) external view returns (bool);\n    function allPoolsLength() external view returns (uint);\n\n    function isTimelock(address) external view returns (bool);\n\n    function createPool(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        uint delayTimeLock\n    ) external returns (address pool);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setFeeToken(address _token) external;\n    function setFeeAmount(uint _token) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/test/IOriginUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IOriginUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IFireBirdERC20.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IFireBirdERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}